# 算法课笔记(上部)

## 第二章 位运算

### 基础知识

计算机中对二进制数的表示逻辑：

正数：正常表示，最高位为符号位，0为正，1为负

负数：最高位为符号位，0为正，1为负，补码表示（原码取反加一）

因此，一个Byte(8位二进制)取出最高位符号位之外，最大可以表示的数字就是127(0111 1111)，照理来说负数也同理，但是这里存在一个特殊的情况1000 0000，按照前面的说法是-0，这个数字没有意义，因此把这个数字定义为-128，因此一个Byte的表示范围就变成(-128~127)

移位操作：>>/<< 移动时符号位均保持不变。

### 例题

> **异或用于解决问题**

136: 只出现一次的数字

389: 找不同

> **n&(n-1)运算解决问题**

这个东西有两种用途：

1. **判断一个数是否为2的整数次幂**

若n&(n-1)为0， 则确认为2的整数次幂

例题：231

2. **n &= n - 1**

**这个运算可以将原二进制数n的最后一位1改为0，其他数字维持不变。**

例题：剑指Offer15 二进制中1的个数：

```java
public int hammingWeight(int n) {
    int res = 0;
    while (n != 0) {
        n &= n - 1;
        res++;
    }
    return res;
}
```



例题：191

注：191要求已无符号整型的角度来对待输入，实际上因为采用了位运算形式，所以本身符号位也参与运算，也就是说本身这种方法就是符合题意的，无需再行处理。

> 针对数据量很大的情况，可以使用BitMap思想处理，其实也就是一个类似于散列表的思想，这里可以用到一个特殊的java数据类型，bitSet，提供了设置不同位数取值的功能。

例题：318

```java
给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。

示例 1:

输入: ["abcw","baz","foo","bar","xtfn","abcdef"]
输出: 16 
解释: 这两个单词为 "abcw", "xtfn"。
示例 2:

输入: ["a","ab","abc","d","cd","bcd","abcd"]
输出: 4 
解释: 这两个单词为 "ab", "cd"。
示例 3:

输入: ["a","aa","aaa","aaaa"]
输出: 0 
解释: 不存在这样的两个单词。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-product-of-word-lengths
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

上面这个题有两个基本思路：

1. 节省判定两个字符串是否有公共字符的时间：

这一点可以通过对字符串进行编码为int型(这里假定都为)，而后对两个字符串进行&操作，若结果为0，则说明二者没有公共字符串。

2. 节省两两遍历字符串的时间

这个也比较好理解，如果直接遍历的话，会引入O(N^2)的时间复杂度，这里可以通过将拥有相同编码（也就是用用相同字符组成）的字符串简化，只保留最长的那个进行运算(实际上是通过HashMap实现的)。

代码如下：

```java
//318. 最大单词长度乘积
public int maxProduct(String[] words) {
    int[] targets = new int[words.length];
    Map<Integer, Integer> resMap = new HashMap<>();
    for (int i = 0; i < words.length; i++) {
        String s = words[i];
        int val = 0;
        for (int j = 0; j < s.length(); j++) {
            val |= (1 << (s.charAt(j) - 'a'));
        }
        targets[i] = val;
        if (resMap.get(val) == null || resMap.get(val) <= s.length()) {
            resMap.put(val, s.length());
        }
    }
    int max = 0;
    for (int i : resMap.keySet()) {
        for (int j : resMap.keySet()) {
            if ((i & j) == 0 && resMap.get(i) * resMap.get(j) >= max) {
                max = resMap.get(i) * resMap.get(j);
            }
        }
    }
    return max;
}
```

例题：

```
//剑指 Offer 56 - I. 数组中数字出现的次数
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
```

这个题比之前那个都要复杂一些，如果是找一个的话，只要直接异或就完事了，但找两个显然不行，这里的思路是“**分组异或**”，也就是需要把原数组分为两组，保证：

1. 一对相同的数字都在同一组。
2. 要找的两个只出现一次的数字分别在两个不同的组。

要做到这一点，看似很难，实际上还是有办法的，我们知道，假设我们要找的数字为a、b，如果我们直接对整个数组全部进行异或，最终得到的结果必定是a^b，对他进行二进制表示，那么每个二进制位上对应的数字代表什么意思呢？比方说，我们取其中一位xi(i为位数)，xi如果取0，那就说明a和b两个数字在第i位二进制上取值相同，反之则取值不同，我们可以从这一点入手做文章：

首先直接全体异或找到a^b，而后随便找一个为1的位数，而后，将全部数字中该位为1的放在一组，为0的放在另外一组，即可满足我们的1，2条件，我们来分析下，首先仅对于a、b两个数字而言，这样以来肯定是被分在不同组了，所以2是满足的，而对于1，也好理解，两个相同的数字，那么在我们选取的二进制位上取值肯定也相同过，因此他们也会被安全的分到同一组，大功告成，这里我们为了方便 起见，选取的二进制位直接就是最低的为1的那一位，答案如下，注意，0与任何数异或都等于它本身，因此可以将0作为异或的初始值。

```java
public int[] singleNumbers(int[] nums) {
    int test = nums[0];
    for (int i = 1; i < nums.length; i++) {
        test ^= nums[i];
    }
    int mod = 1;
    while ((mod & test) == 0) {
        mod = mod << 1;
    }
    int a = 0, b = 0;
    for (int num : nums) {
        if ((num & mod) != 0) {
            a ^= num;
        } else {
            b ^= num;
        }
    }
    return new int[]{a, b};
}
```



## 第三章

### 3-2 越界

判断计算后数字是否越界的两种方式：

1. 使用long型接受计算后的数字，而后把之与int的最大值/最小值比较即可。
2. 使用int型接受计算后的数字，而后进行逆运算，看结果与原值是否相同（因为越界的原因，计算后数字较原有的正常计算值发生较大变化，因此可用逆运算比较的形式判断是否越界）。

例题： 6



### 3-3 进位

例题：66

```java
    public int[] plusOne(int[] digits) {
        if (digits == null || digits.length == 0) {
            return null;
        }
        for (int i = digits.length - 1; i >= 0; i--) {
            if(digits[i] < 9) {
                digits[i] ++;
                return digits;
            } else {
                digits[i] = 0;
            }
        }
        int[] res = new int[digits.length + 1];
        res[0] = 1;
        return res;
    }
```

​		这个题目解法的精髓在于大大简化了计算，除了正常进位以外，仅需考虑一种特殊情况，即进位溢出(如999加1进位至1000的情况)。

### 3-4 符号字母&牛顿开方

符号字母比较简单，主要就是一个`Charcter.isDigit()`的方法，不需要多讲。

例题：8

主要说一下牛顿开方：

记住逼近公式：

对于非线性方程f(x) = 0，其逼近方程位：

x(n+1) = x(n) - f(xn) / f'(xn)

那么，对于开方这种情况而言，

方程为 x^2 - k = 0，推导其逼近公式为：

x(n+1) = (xn + k / xn)  / 2

就此成功。

例题：367：有效平方数(这里展示常规的二分以及牛顿迭代法)

```java
    public boolean isPerfectSquare(int num) {
        if (num < 0) {
            return false;
        }
        if (num == 0 || num == 1) {
            return true;
        }
        int low = 1;
        int high = num;
        while (low <= high) {
            long mid = low + (high - low) / 2;
            if (mid * mid == num) {
                return true;
            }
            if (mid * mid > num) {
                high = (int) mid - 1;
            } else if(mid * mid < num) {
                low = (int)mid + 1;
            }
        }
        return false;
    }

    //367. 牛顿法(二分查找)
    public boolean isPerfectSquare1(int num) {
        if (num < 0) {
            return false;
        }
        if (num == 0 || num == 1) {
            return true;
        }
        long res = num;
        while (res * res > num) {
            res = (res + num / res) / 2;
            if (res * res == num) {
                return true;
            }
        }
        return false;
    }
```

这个牛顿法里边需要注意的点在于那个`res * res > num`的终止条件，这个原因在于牛顿迭代本身对于开方这种方程而言，都是会从解的一侧(本例中为大于解的一侧)逼近解，因此当`res * res > num`，不再成立时，说明或者已经找到整数解，又或者已经越过原整数解。因此可以作为终止条件。

### 练习题

258：各位相加（数学公式）

43：字符串相乘（这个要好好讲一下）

首先是题目描述

```java
给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。

示例 1:

输入: num1 = "2", num2 = "3"
输出: "6"
示例 2:

输入: num1 = "123", num2 = "456"
输出: "56088"
说明：

num1 和 num2 的长度小于110。
num1 和 num2 只包含数字 0-9。
num1 和 num2 均不以零开头，除非是数字 0 本身。
不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。
```

​		其实从题干来分析，最大的坑其实是这里的输入本身的数字是可能会远远大于java本身的基础数据类型的表示范围的，并且还不允许使用大数类型来操作，那其实解法就是暴力列竖式操作了，如下：

```java
//整个解法其实分两个大的部分（也就是竖式乘法的两个大部分）
//1. 分别用乘数的各位去乘以被乘数的各位，得到一连串数字（末尾注意自动补零）
//2. 将1中获取的各数相加。
//上述步骤每一步的结果均需一字符串形式存储。

class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) {
            return "0";
        }
        int m = num1.length(), n = num2.length();
        StringBuffer res = new StringBuffer("0");
        for (int i = n - 1; i >= 0; i--) {
            int c = num2.charAt(i) - '0';
            StringBuffer buffer = new StringBuffer();
            for (int j = 0; j < n - 1 - i; j++) {
                buffer.append("0");
            }
            int next = 0;
            for (int j = m - 1; j >= 0 ; j--) {
                int d = num1.charAt(j) - '0';
                int mult = d * c + next;
                buffer.append(mult % 10);
                next = mult / 10;
            }
            if (next != 0) {
                buffer.append(next);
            }
          	//获取上述1.中所述的各个结果
            addString(res, buffer.reverse().toString());
        }
        return res.toString();
    }
		//将各个结果相加。
    private void addString(StringBuffer origin1, String add) {
        String origin = origin1.toString();
        int n = Math.max(origin.length(), add.length());
        origin1.setLength(0);
        int carry = 0;
        for (int i = 0; i < n; i++) {
          	//重要，下面会讲。
            int ai = origin.length() - 1 >= i ? origin.charAt(origin.length() - 1 - i) -
              '0' : 0;
            int bi = add.length() - 1 >= i ? add.charAt(add.length() - 1 - i) - '0' : 0;
            int tmp = ai + bi + carry;
            origin1.append(tmp % 10);
            carry = tmp / 10;
        }
        if (carry != 0) {
            origin1.append(carry);
        }
        origin1.reverse();
    }
}
```

​		基本的思路都在上面说过了，这里说一个小技巧，就是对两个不同位数的字符串整数相加时的对齐问题，这里采用从个位从右向左的方式相，基本模版套路如下：

```java
        for (int i = 0; i < n; i++) {
          	//注意这里，是最重要的两句，本质是从末尾（低位）相最高位遍历，这个过程中遍历变量i指的是从末位倒数第几位，这样就可以简单通过判定是否越界决定是否取零，巧妙解决了两个加数位数长度不同的对齐问题。。
            int ai = origin.length() - 1 >= i ? origin.charAt(origin.length() - 1 - i) -
              '0' : 0;
            int bi = add.length() - 1 >= i ? add.charAt(add.length() - 1 - i) - '0' : 0;
            int tmp = ai + bi + carry;
            origin1.append(tmp % 10);
            carry = tmp / 10;
        }
        if (carry != 0) {
            origin1.append(carry);
        }
```

​		这个模版要记住。

二分模板：

```java
// 69. x的平方根(二分)
public int mySqrt(int x) {
  if (x <= 0) {
    return 0;
  }
  int low = 0;
  int high = x;
  int target = x;
  int ans = 1;
  while (low <= high) {
    int mid = low + (high - low) / 2;
    if ((long)mid * mid == target) {
      return mid;
    }
    if ((long)mid * mid <= target) {
      ans = mid;
      low = mid + 1;
    } else {
      high = mid - 1;

    }
  }
  return ans;
}
```



## 第四章 数组

本章主要考察的是一些双指针问题，没有太明确的套路，只能写几个典型例题来看了。

### 4-1 会议室类型题目

1. **252  会议室1**

这个题是给定了一个区间数组（指代同一场会议的开始、结束时间），然后判断这些会一能否在一个会议室开完，这个的思维套路是这样：要想在一个会议室开完，必须是连着开，**一个关键的条件就在于，上一场开始的会议结束的时间一定要小于等于下一场会议开始的时间**，这样的话，就需要首先按照开始时间对区间进行排序，而后挨个判断是否满足条件即可。

2. 253 **会议室2**

这个问题与1类似，依旧是给出区间数组，但这一次是让判断最少需要几个会议室可以完成这些会议，这个东西我理解的思维方式是：

```
首先将会议开始、结束时间分别排序放到两个不同数组里边，然后设想这么一场景，每一个人在会议马上开始时到达时，需要去找一个最早的会议结束时间，然后进行判断，如果最接近结束的会议此时已经结束，则使用那个会议室（即不需要重开会议室），但是如果接近结束的会议仍然没有结束，则需要新开一个会议室
```

```java
public int minMeetingRooms(int[][] intervals) {
    int[] starts = new int[intervals.length];
    int[] ends = new int[intervals.length];
    for (int i = 0; i < starts.length; i++) {
        starts[i] = intervals[i][0];
        ends[i] = intervals[i][1];
    }
    Arrays.sort(starts);
    Arrays.sort(ends);
    int end = 0;
    int res = 0;
    for (int i = 0; i < starts.length; i++) {
        if(starts[i] < ends[end]) {
            res ++;
        } else {
            end ++;
        }
    }
    return res;
}
```

### 4-2 双指针类型题目

1.子数组-进行中处理(209.长度最小的子数组)

这个题的核心其实在于滑动窗口，窗口首先从最左边开始向右扩张，知道前缀和(即前段累积和)满足条件，之后开始从左端收缩直至刚好不满足条件，此时记录一个最短长度，而后继续向右扩张，这样最终计算出的最小值即为结果。

```java
public int minSubArrayLen(int s, int[] nums) {
    int res = Integer.MAX_VALUE;
    int sum = 0;
    int left = 0;
    for (int i = 0; i < nums.length; i++) {
      sum += nums[i];
      while (left <= i && sum >= s) {
        res = Math.min(res, i - left + 1);
        sum -= nums[left++];
      }
    }
    return res == Integer.MAX_VALUE ? 0 : res;
}
```

这种东西的模版其实是这个：

```java
for (int i = 0; i < nums.length; i++) {
    sum += nums[i];
  	...
}
```

2. 子数组-分段式处理

分段式处理的含义在于**，你不可能再一次过程中，在计算前缀和的同时处理需要的结果，因此需要第二次循环，这也就是分段式的概念**。

   	来看一个例题：

   ```
   给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
   
    
   
   示例:
   
   输入: [1,2,3,4]
   输出: [24,12,8,6]
    
   
   提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。
   
   说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。
   
   进阶：
   你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
   
   ```

   这是一个标准的子数组问题，因此需要用子数组处理方式进行，这里的分析思路如下：

   ```
   //这个题要求将int数组的每个元素转化为原数组中除它自己以外元素的乘积，这样就很容易想到前缀和*后
   //缀和
   //这个题的逻辑其实可以理解为先正向乘一遍，算出一个前缀积数组，而后再反向来一边，来一个后缀积数组
   //而后两个数组元素两两相乘即可得到结果，不过这样会有三个for循环，仔细研究一下，我们会发现，其实
   //计算后缀积的时候，没算完一个，可以直接乘上原来记录的前缀积得到结果，因此可以省去第二次for循环
   //直接得到结果。
   ```

   代码如下，这里要注意的是在第二次循环中巧妙运用中间遍历temp，避免进行第三次循环的方法：

   ```java
   public int[] productExceptSelf(int[] nums) {
     if (nums == null || nums.length == 1) {
       return nums;
     }
     int[] res = new int[nums.length];
     res[0] = 1;
     for (int i = 1; i < nums.length; i++) {
       res[i] = nums[i - 1] * res[i - 1];
     }
     int temp = 1;
     for (int i = nums.length - 2; i >= 0; i--) {
       temp *= nums[i + 1];
       res[i] *= temp;
     }
     return res;
   }
   ```

   3. 双向双指针

这类题目较为公式化，往往一看就需要从两边到中间遍历，即采用双指针形式，模版如下：

   ```java
int l = 0;
int r = height.length - 1;
int res = 0;
while (l < r) {
  	...
}
return res;
   ```

   这里涉及数组的介绍一道经典题目。

LC 11:盛水最多的容器：

这个题其实不难看出是双指针，男的地方在想到左右指针的移动策略，

核心就一句话：永远优先移动较短的那一边！！！

这个策略可以简单分析一下：

首先，由于问题的性质，必然是采用双向双指针从两边向中间移动，移动的过程中不断记录调整最大值，那这里很显然，我们在移动两边指针的时候总会有这么个疑问：**会不会因为我这次移动导致后续漏计算真正的最大值呢？也即是说，如果我本次不移动这个指针，那边是否后续还会有该指针位于这个位置，且容积更大的情况发生呢？**，从这里开始，我们就可以分析“优先移动较短边”这种策略的合理性了，我们知道，题目的要求，容器实际上取决于**较短边与两边距离的乘积**，那显然，如果我们不移动较短边，那后续这个式子中较短边只会继续变小(或不变)，二两遍距离则是一定会变小了，因此不存在所谓不移动较短边，后续会有容积更大的情况发生，也就是说，移动较短边是一个绝对安全的选择，因此我们选择始终优先移动较短边。代码如下：

```java
public int maxArea1(int[] height) {
    int l = 0;
    int r = height.length - 1;
    int res = 0;
    while (l < r) {
        res = Math.max(Math.min(height[l], height[r]) * (r - l), res);
      	//优先移动较短边，代码很简单，难的地方在于思维过程。
        if (height[l] < height[r]) {
            l++;
        } else {
            r--;
        }
    }
    return res;
}
```

### 4-3 二维数组

二维数组此处所指的主要考察目标是旋转变换类型题目，这里需要注意，所有的此类旋转变换类型题目均可由以下几种变换组合而来：

```java
1. 垂直变换
2. 水平变换
3. 对称轴变换（主/副对角线）
```

特殊题型：二维数组变换—暴力解决(主要考察队遍历过程中循环变量的掌握)——**LC. 54**

### 4-4 实现类题目

此类题目与上面说的套路不同，纯考察逻辑思维能力：

例题：LC. 277

### 4-5 数学定理

例题：LC. 169

### 4-6 数组例题训练总结

> 1. 数组操作

**例题**：LC. 26、LC. 27、LC. 80

**分析**：这类题的共同特定在与要求对一个一维数组**原地的**删除某些特定元素，而后返回完成后的元素长度，这里我们使用单指针即可，指针始终指向最后一个满足条件的元素，遍历过程中每发现有满足条件的元素就前移至指针处，之后指针右移。

这类题有模板：

```java
public int removeDuplicates(int[] nums) {
  	int left = 0;
		...
  	for (int i = 1; i < nums.length; i++) {
        if(nums[i] != nums[left]) {
            ...
    		}
  	}
  	return left + 1;
}
```

这里我们看一个比较难一点的例子

LC. 80：

```java
给定一个增序排列数组 nums ，你需要在 原地 删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
```

分析：这题我们可以发现其实和我们之前看的那种模板题区别不大，只是增加了一个条件，即每个数字允许最多出现两次，因此我们可以使用一个count遍历来追加记录辅助即可。

```java
public int removeDuplicates(int[] nums) {
  	int left = 0;
  	int count = 1;
  	for (int i = 1; i < nums.length; i++) {
        if(nums[i] != nums[left]) {
            nums[++left] = nums[i];
            count = 1;
        } else {
            if (count < 2) {
              nums[++left] = nums[i];
            }
            count++;
      	}
  	}
  	return left + 1;
}
```

> 2. 单/双指针

> > 2.1 区间问题

例题：LC 56、57、252、253

> > 2.2 扫描线

例题：LC 228、163

> > 2.3 子数组(分为进行中和分段)

> 3 二维数组旋转

例题：LC 48：图像旋转(顺时针旋转90度)

这类题目比较典型，比较单一，总的来说就是做动作拆解，记住

```java
顺指针旋转90度 = Y轴对称 + 正对角线轴对称(这个要轻松一些)
或者
顺指针旋转90度 = X轴对称 + 负对角线轴对称(这个完全是找罪受)
```

这里就不婆婆妈妈了，直接上全代码：

```java
//X轴对称
public void rotateInX(int[][] matrix) {
    int N = matrix.length;
    for (int i = 0; i < matrix.length; i++) {
        int tmp = 0;
        for (int j = 0; j < N / 2; j++) {
            tmp = matrix[i][N - j - 1];
            matrix[i][N - j - 1] = matrix[i][j];
            matrix[i][j] = tmp;
        }
    }
}
//Y轴对称
public void rotateInY(int[][] matrix) {
    int N = matrix.length;
    for (int i = 0; i < N / 2; i++) {
        int tmp = 0;
        for (int j = 0; j < matrix.length; j++) {
            tmp = matrix[N - i - 1][j];
            matrix[N - i - 1][j] = matrix[i][j];
            matrix[i][j] = tmp;
        }
    }
    int i = 1;
}

//正对角线轴对称
public void rotateInPosCross(int[][] matrix) {
    int N = matrix.length;
    for (int i = 0; i < N; i++) {
        int tmp;
        for (int j = 0; j < i; j++) {
            tmp = matrix[j][i];
            matrix[j][i] = matrix[i][j];
            matrix[i][j] = tmp;
        }
    }
}
//负对角线轴对称
public void rotateInNegCross(int[][] matrix) {
    int N = matrix.length;
    for (int i = 0; i < N; i++) {
        int tmp;
        for (int j = 0; j < N - 1 - i; j++) {
            tmp = matrix[N - 1 - j][N - 1 - i];
            matrix[N - 1 - j][N - 1 - i] = matrix[i][j];
            matrix[i][j] = tmp;
        }
    }
}
```

例题：LC. 54螺旋矩阵（一道极其特殊的题型，就考你循环暴力解的能力）



例题(超级高频)：[15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

这个题我要讲一下我的心路历程，首先是最笨的办法，就直接吧两数之和这玩意搬过来用，结果可想而知，直接干到200多ms，玩个蛋，

接下来学聪明了，利用双指针，从左向右遍历判断去重，效果好一些了：

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> retList = new ArrayList<>();
        if (nums == null || nums.length < 3) {
            return retList;
        }
        Arrays.sort(nums);
        Map<Integer, Integer> map = new HashMap();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);
        }
        int l = 0, r = 1;
        while (l < nums.length) {
            if (r == nums.length) {
                l = getNextIndex(nums, l);
                r = l + 1;                
            }
            if (l >= nums.length || r >= nums.length) {
                continue;
            }
            while (r < nums.length) {
                int tar = 0 - nums[l] - nums[r];
                if (map.containsKey(tar) && map.get(tar) > r) {
                    retList.add(Arrays.asList(nums[l], nums[r], tar));
                }
                r = getNextIndex(nums, r);
            }
        }
        return retList;
    }

    public int getNextIndex(int[] nums, int l) {
        int val = nums[l];
        while (l < nums.length && nums[l] == val) {
            l ++;
        }
        return l;
    }
}
```

现在到100多ms了，好了一些，但还是有问题，最后看了答案，最开始我一直没搞明白我和答案的差距到底在哪里，先看代码：

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> retList = new ArrayList<>();
        Arrays.sort(nums);
        int first = 0, second = 1;
        for (first = 0; first < nums.length; first++) {
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            int target = -nums[first];
            int third = nums.length - 1;
            for(second = first + 1; second < third; second ++) {
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                while (third > second && nums[third] + nums[second] > target) {
                    third --;
                }
                if (third == second){
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    retList.add(Arrays.asList(nums[first], nums[second], nums[third]));
                } 
            }
        }        
        return retList;
    }
}
```

最开始我一直没有搞明白这玩意和我写的东西比起来，时间省在哪里，后来想明白了，我上面那种相当于用map操作代替了第三种方法种，对第三个数循环判定的过程，但这样其实会增加一些无谓的消耗，比方说，如果你本次通过map映射获取的第三个值的index比first和second都要小，那因为去重的原因，这里必须干掉，相当于白忙活，而对第三个继续采用从末端想第二个数所在位置进行遍历则不存在这个问题，并且实际上，遍历数组要比查询hashMap的耗时低的多。

其实从上面着整个优化过程来看，就能看出这个题的厉害之处了，其实本质上它没有多少太深奥的算法在里边，但因为题目本身的原因，导致无论如何优化，时间复杂度都在O(N^2)，并且用例应该包含了那种量很大的数据，导致任何一丁点优化，就算不会在时间复杂度上产生本质变化，但也会导致耗时发生数倍的变化，因此非常考察优化能力。

## 第五章 二分法

### 5-1 迭代形式总结

​		二分法的迭代一共有三种形式，分别是`left <= right`、`left < right`、 `left + 1 < right`，这三种殊途同归，但其区别非常重要，我们必须完全了解这三种写法再找不到目标值的情况下，最终左右指针指向的位置有何种不同，因为实际上，并不会有一个题让你真的去线性表里边着一个精确值，更多的是求解一个最接近的值，比如之前提到过的开方，要求拿到一个最接近的整数值，这种就要求我们对三种迭代形式在找不到的情况下的最终指向位置。

先来看看这三种基本的迭代形式：

> 1. Left <= right

代码如下：

```java
//这中写法从头到位都保持所搜索的区间始终位[start, end]
public int binarySearch(int[] nums, int target) {
    int start = 0;
    int end = nums.length - 1;  //初始化搜索全数组，范围为[start, end]
    while (start <= end) {
        int mid = start + (end - start) / 2;
        if (nums[mid] > target) {
          	end = mid - 1;            //选左半边数组，[start, mid - 1]
        } else if (nums[mid] < target) {
          	start = mid + 1;					//选右半边数组, [mid + 1, end]
        } else {
          	return mid;
        }
        System.out.println("start = " + start + " end = " + end);
    }
    System.out.println("start = " + start + " end = " + end);
    return -1;
}
```

这种写法不要要硬背，主要记住，从头到尾都保持搜索区间始终位`[left, right]`的闭区间即可。

需要注意，这种写法在找不到准确值的情况下，最终两个指针指向的索引分别为:

```java
nums[right] < target < nums[left]👎left = right + 1(这一点从这个算法此时的终止条件也可以看出)
注意, target本身在数组之外时，可能有left = 0, right = -1或者left = nums.length且right = nums.length - 1; 
```

> 2. left < right

```java
//这中写法从头到位都保持所搜索的区间始终位[start, end）
public int binarySearch1(int[] nums, int target) {
    int start = 0;
    int end = nums.length;                //初始化位[0, nums.length - 1)
    while (start < end) {
        int mid = start + (end - start) / 2;
        if (nums[mid] > target) {
            end = mid;										//选择左半边,[start, mid)
        } else if (nums[mid] < target) {
            start = mid + 1;
        } else {
            return mid;										//选择右边边,[mid + 1, end)
        }
        System.out.println("start = " + start + " end = " + end);
    }
    System.out.println("start = " + start + " end = " + end);
    return -1;
}
```

这种写法是需要全程保持搜索区间为`[start, end)`的左闭右开区间的。

注意：这种写法下最终没有找到`target`的时候，结果如下：

```java
left = right = x 且 nums[x] > target && nums[x - 1] < target;
总之就是最终会指向恰好大于target的数字的索引，当然，同样可能取0或者nums.length
```

> left + 1 < right

```java
    //这个题没有明确的开闭区间这种说法了。。。。
		public int binarySearch3(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
      	//需要注意的是这个条件导致最后start和end相邻的时候就会结束循环，必有一个未被考察。
        while (start + 1 < end) {
            int mid = start + (end - start) / 2;
            if (nums[mid] > target) {
                end = mid;
            } else if (nums[mid] < target) {
                start = mid;
            } else {
                return mid;
            }
            System.out.println("start = " + start + " end = " + end);
        }
      	//因此最后需要追加一次对start和end的考察。
        if (nums[start] == target) {
            return start;
        } else if (nums[end] == target) {
            return end;
        }
        System.out.println("start = " + start + " end = " + end);
        return -1;
    }
```

第三种写法下若找不到，则返回值如下：

```java
1. 常规情况：
  nums[start] < target < nums[end]
2. 极端情况下：
  start = 0, end = 1（target < nums[0]）
  start = nums.length - 2, end = nums.length - 1(target > nums[1])
```

### 5-2 实战例题

Lc35. 搜索插入位置

```java
    // 35. 搜索插入位置
    public int searchInsert(int[] nums, int target) {
        if (nums == null) {
            return -1;
        }
        int start = 0;
        int end = nums.length - 1;
        while (start <= end) {
            int mid = start + (end - start) / 2;
            if (nums[mid] < target) {
                start = mid + 1;
            } else if (nums[mid] > target) {
                end = mid - 1;
            } else {
                return mid;
            }
        }
        return start;
    }

```

​		这个题属于最简单的题型，其实就是抄模版就完事了。

Lc 278. 第一个错误的版本

```java
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int start = 1;
        int end = n;
        while(start <= end) {
            int mid = start + (end - start) / 2;
            if (isBadVersion(mid)) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        return start;
    }
}
```

这个题其实也是TM的抄写模版，需要转换思路，可以转换为寻找一个数组中绝对不存在的值的插入位置。



LC. 33 搜索旋转排序数组

```java
给你一个升序排列的整数数组 nums ，和一个整数 target 。

假设按照升序排序的数组在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。

请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

 
示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：

输入：nums = [1], target = 0
输出：-1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

​		这个题就有意思了，乍看之下完全没有头绪，根据老师讲的，其实也就大体是是两种情况，在计算完中间值mid后，即可确定拐点在那一半区间，无非是拐点在mid之前，或者拐点在mid之后两种情况而已。

```java
    public int search(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
        while (start <= end) {
            int mid = start + (end - start) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if (nums[mid] >= nums[start]) {
                if (target >= nums[start] && target < nums[mid]) {
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }
            } else if (nums[mid] <= nums[end]) {
                if (target > nums[mid] && target <= nums[end]) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }
        return -1;
    }
```

​		上面这一大段程序整个还是可以看出普通的二分迭代的版本，与普通版本不同的点在于，其判断下一步往哪边遍历的部分要复杂一些：

​		这个题告诉我们的道理是：

​		**二分法就是二分法而已，大的模版是不会变动的，只要我们能通过条件将下一步遍历的方向确认好，其他位置的模版是不需要改动的！！！！！！！！！！！！！！！！**

## 第六章 链表

### 前言

链表这一章算是看到现在最简单的一章了，主要还是分为基本操作、反转、删除、环以及递归写法等。

### 6-1 基本操作

​		基本操作要记住一个大的原则：

```java
如果算法运行过程中，头节点不需要变化，则一般不需要在头节点前补节点
如果算法运行过程中，头节点可能会变化，则一般需要在头节点前补节点(我们称之为dummy节点)
```



### 6-2 反转

​		反转这个东西本身是基础且简单的，但是会有一些衍生的类型，涉及到翻转循环方式的选择。这里说一种比较“别扭”的写法，总结起来一句话，每次都将当前遍历的节点移动到翻转开始的头节点位置，具体描述如下：

```java
//这个地方算法的核心其实是：
//每次都把下一个节点移向队首：
//要做到这一点，收看需要一个假的头节点dummy，而后每次将head的下一个节点移向头节点
//举例来说：
//对于 1 -> 2 -> 3 -> 4 -> 5 -> 6
//首先新增一个头节点0：
//0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6
//而后
//(pre)0 -> (head)1 -> (tmp)2 -> 3 -> 4 -> 5 -> 6
//我们把tmp移动向队首：
//(pre)0 -> 2 -> (head)1 -> (tmp)3 -> 4 -> 5 -> 6
//继续:
//(pre)0 -> 3 -> 2 -> (head)1 -> (tmp)4 -> 5 -> 6
//以此类推，最终得到结果
//这个方法其实整体来说是比原方法复杂的多的，这个题没啥意义，主要针对下一题LC. 92
```

代码实现如下：

```java
public ListNode reverseList1(ListNode head) {
    if (head == null || head.next == null) {
      return head;
    }
    ListNode pre = new ListNode(0);
    pre.next = head;
    while (head.next != null) {
        ListNode tmp = head.next;
        head.next = tmp.next;
        tmp.next = pre.next;
        pre.next = tmp;
    }
    return pre.next;
}
```

这个算法有点费力不讨好的意思，但在一些较难的算法题型中有奇效：

如LC. 92：

```java
92. 反转链表 II
给定链表及其整数m、n:将链表中第m个节点与第n个节点之间的部分翻转
```

这个题如果用常规方法来写的话，需要考虑的东西可多了：

```java
1. 首先需要记录m之前的节点以及第m个节点.
2. 从m到n，执行常规翻转，这个过程中，原第n个节点也要记录。
3. 这个时候链表已经被拆成三个部分，最后需要依据之前记录的节点(其实也就是断开原链表的位置节点)将三部分重新连接。
```

这个时候，我们就会发现，之前那个看起来别扭的翻转链表算法就有了大用处：

```java
1.仍然需要遍历得到第m个节点及其之前的节点.
2.直接从m到n循环执行翻转即可。
```

这个时候我们就会发现，由于之前那种算法的特殊结构，就省略了最为麻烦的断点记录以及重新连接过程，在翻转的自然过程中，这些东西都是自然而然就完成了的。

## 第七章 随机

### 7-1 等概率抽取法

先来个背景：

写个算法，从n个数中随机抽取m个数，

一个很容易想到的方法是：

```java
1. 第一个数从n个数中随机取，取到多少算多少。
2. 之后的数字依旧是从n个数中随机取，但是一旦取到的数字被选择过，则抛弃，继续随机取。
```

这个方法使用java本身的`random`方法很简单，我们这里也不讨论具体实现，而是讨论这个东西，他的时间复杂度是多少？下面是推导过程。

```java
假设我们某一个数的抽取中，前面已经选中了x个数，那么：
1.一次抽取成功的概率为：1 - x / n；
2.二次抽取成功的概率为：(1 - x / n)* (x / n)
3.三次次抽取成功的概率为：(1 - x / n)* (x / n) ^ 2
...
k.k次抽取成功概率为：(1 - x / n)* (x / n) ^ 3

好了，进入下一步，计算所需次数的期望值：
S = 1 * P(1) + 2 * P(2) + ... + k * P(k) = n / n - x;
(这里其实是一个典型的等差 * 等比数列的求和取极限，求和的方法是交错相减法(高中知识，我还记得😄))

最后一步，每一个数的抽取期望次数想加得到：
Sn = n / n + n / n - 1 + n / n - 2 + ... + n / n - m + 1 = O(n(lg(n) - lg(n - m)))
可以发现，最坏情况下, m = n - 1(m = n还抽个鸡儿)，时间复杂度达到O(nlog(n))级别。
显然是不可接受的。
```

### 7-2 蓄水池抽取法

​		蓄水池抽取法适用于这样一种场景，即n中随机抽1，或n中随机抽m，我们实现不知到n有多大，对应于实际的应用场景来说，就是：设想这样一种情况，我们随机抽取的对象是一个不断给出的输入流，其中的数字可能达到百亿级别，我们本地的内存无法同时存储这么大量的数据，这就导致我们无法在输入流全部给出后再执行随机操作，因此必须在输入流输入的同时进行处理，这个时候就需要用到蓄水池抽取法了：

> n选1

​		n选1这种比较简单：

```
我们遍历整个流，在遍历每一个元素时，均执行一次随机操作：
1.对于第一个元素，我们总是选中，或者说以1/1的概率决定是否选中，选中后，暂时定位抽取值。
2.对于第k个元素，我们以k/1的概率决定是否选中，若选中，则代替原有的抽取值成为暂定的抽取值。
这样，一次遍历结束以后，最终的抽取值即为我们需要的值。

————————————————————————————————————————分割线————————————————————————————————————————

接下里，我们来推导一下这种方案的合理性：
简单来说，来看看第m个元素被选中的概率：
这里就会有两个条件：
1.遍历到第m个元素是，他必须被选中。
2.m之后的元素必须全部不被选中。
那么最后的概率即使
P = 1/m * m/m+1 * ... * k-1/k = 1/k
这么看，就没有问题了。
```

代码实现如下：

```java
//蓄水池抽样法 n选1
public int pick1(int[] nums) {
    int res = -1;
    Random random = new Random();
    for (int i = 0; i < nums.length; i++) {
        if (random.nextInt(i + 1) == 0) {
            res = i;
        }
    }
    return res;
}
```



> n选m

n选m就复杂的多了：

```
我们同样遍历整个流，但是前m的元素不经过遍历，直接放到一个容器中，之后对于第k个元素(k>m)，首先以m/k的概率决定是否选中，选中后，再以1/m的概率随机抽取容器中的一个元素与之交换，这样最后容器中剩余的元素即为随机抽取的结果，且可保证，每一个元素被选中的概率都是m/n
  
————————————————————————————————————————分割线————————————————————————————————————————

同样，来做推导，以第k个元素为例(假设k > m),这个元素要被选中，同样有几个条件需要满足：
1.其本身必须在遍历过程中被选中与容器中的任意元素交换。
2.其后的每个元素都必须不被选中或者被选中但是与容器中元素交换时未影响该元素。
1条件中的概率很简单，就是P1 = m/k
2条件复杂一些，我们先来只看针对k+1这个元素的概率：
P(k+1) = k+1-m/k+1 +  m/k+1 * m-1/m = k / k + 1
哎，这样结合起来就是
P = P1 * P(k+1) * P(k+2) * ... * P(n)
  = m/k * k/k+1 * k+1/k+2 * n-1/n
  = m/n
```

```java
//蓄水池抽样法 n选m
public int[] pick2(int[] nums, int m) {
    int[] res = Arrays.copyOf(nums, m);
    Random ran = new Random();
    for (int i = m; i < nums.length; i++) {
        int randomIdx = ran.nextInt(i + 1);
      	//注意这里，是个很好的技巧，因为randomIdx < m时，实际上其取值已经是经过1/m概率抽样之后的值了。
        if (randomIdx < m) {
            res[randomIdx] = nums[i];
        }
    }
    return res;
}
```

> 洗牌算法







## 排序算法总结

### 1 概述

> 插入排序

基本思路为：数组分为两堆，一堆已完成排序，另一堆等待排序，每次从后一个堆中取出一个元素，插入到前堆的正确位置即可。

```java
public void insertSort(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return;
    }
    for (int i = 1; i < nums.length; i++) {
        int tmp = nums[i];
        int j = i - 1;
        while (j >= 0 && nums[j] >= tmp) {
            nums[j + 1] = nums[j];
            j--;
        }
        nums[j + 1] = tmp;
    }
}
```

插入排序时间复杂度为O(n^2)，空间复杂度为O(1)，为稳定排序(即排序起前后保证原数组中相同大小元素的相对位置保持不变)


> 选择排序

这个是最朴素的一种排序方法，每次都遍历数组，选出最小值放在数组组头，循环下去即可找到最小值。

```java
public void selectSort(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        int min = i;
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[j] <= nums[min]) {
                min = j;
            }
        }
        int tmp = nums[min];
        nums[min] = nums[i];
        nums[i] = tmp;
    }
}
```

插入排序时间复杂度为O(n^2)，最好为O(n)(即原数组有序)，为不稳定排序

> 堆排序

借助堆这个数据结构排序，堆是这样一种数据结构，一个二叉树，每个子数的根结点均为该子数的最大(小)值，有这个堆以后，假设为最大堆，每次将根节点和末尾交换，而后重新排序简历最大堆，循环往复即可完成最后的排序，其空间复杂度为O(1)，时间负责度为O(nlgn)

```java
public int[] HeepSort(int[] nums) {
    int edge = (nums.length - 1) / 2;
    for (int i = edge; i >= 0 ; i--) {
        fixHeep(nums, i, nums.length);
    }
    for (int i = nums.length - 1; i >= 1 ; i--) {
        swapInArray(nums, 0, i);
        fixHeep(nums, 0, i);
    }
    return nums;
}

public void fixHeep(int[] nums, int root, int length) {
    int largest = root;
    int left = 2 * root + 1;
    int right = 2 * root + 2;
    if (left < length && nums[left] > nums[largest]) {
        largest = left;
    }
    if (right < length && nums[right] > nums[largest]) {
        largest = right;
    }
    if (largest != root) {
        swapInArray(nums, largest, root);
        fixHeep(nums, largest, length);
    }
}
```

时间复杂度为O(nlgn)。

> 冒泡排序

冒泡排序基本思路为两两交换相邻的两个元素保证其相对顺序，循环进行直到无需交换即可，这里实际操作过程中，完成第一次交换循环后，可保证末尾的元素一定是最大值，无需再行交换，下一次只需要从n-1下标开始即可。

```java
public void bubbleSort(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return;
    }
    boolean sorted = false;
    for (int i = nums.length - 1; i > 0 && !sorted ; i--) {
        sorted = true;
        for (int j = 0; j < i; j++) {
            if (nums[j] > nums[j + 1]) {
                int tmp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = tmp;
                sorted = false;
            }
        }
    }
}
```

标准冒泡排序(不带上面这个`sorted`标记位)的时间复杂度为O(n^2)，而上面这种排序算法其平均复杂度为O(n^2)，但最好情况下则为O(n)

> 归并排序

代码如下：

```java
public int[] mergeSort(int[] nums) {
    if (nums.length > 1) {
        int mid = (nums.length - 1) / 2;
        int[] left = Arrays.copyOfRange(nums, 0, mid + 1);
        int[] right = Arrays.copyOfRange(nums, mid + 1, nums.length);
        left = mergeSort(left);
        right =mergeSort(right);
        return merged(left,right);
    } else {
        return nums;
    }
}

public int[] merged(int[] a, int[] b) {
    int[] res = new int[a.length + b.length];
    int i = 0, j = 0, cur = 0;
    while (i < a.length && j < b.length){
        if (a[i] <= b[j]) {
            res[cur++] = a[i++];
        } else {
            res[cur++] = b[j++];
        }
    }
    if (i == a.length) {
        for (int k = j; k < b.length; k++) {
            res[cur++] = b[j++];
        }
    }
    if (j == b.length) {
        for (int k = i; k < a.length; k++) {
            res[cur++] = a[i++];
        }
    }
    return res;
}
```

该算法时间复杂度为O(nlgn)，空间复杂度为O(n)

> 快速排序

快排的基本思路是，每次选取其中一个数字(可取最后一个或者随机取一个)r，将数组原址地分开，将大于r的放在r右边，小于r的放在r左边，而后递归地对这两组循环进行上述操作。

```java
public void quick(int[] nums, int p, int q) {
    if (p >= q) {
        return;
    }
    int tail = nums[q];
    int dummy = p - 1;
    for (int i = p; i < q; i++) {
        if (nums[i] <= tail) {
            dummy++;
            swap(nums, dummy, i);
        }
    }
    swap(nums, dummy + 1, q);
    quick(nums, p, dummy);
    quick(nums,dummy + 2, q);
}

public void swap(int[] nums, int p, int q) {
    int tmp = nums[p];
    nums[p] = nums[q];
    nums[q] = tmp;
}
```

快排的平均时间复杂度为O(nlgn)，最好为O(nlgn)，最坏为O(n^2)，但作为一种原址排序，快排的空间复杂度课认为为O(1)

### 2 例题

```
第K大的元素：
输入一个int型数组nums和一个正整数k，要求返回该数组中第k大的数字
```

这个题目的思维是使用快速排序类似的思想，先取末位数字按照快排的规则进行分区，得到分割数字下标

1. 若分割数字下标来看，目标数字在后半分区，则直接在后半分区寻找第k大的数字
2. 若从分割数字下标来看，目标数字在前半分区，切分割数是第m大的数字，则在前半段中寻找第k - m大的数组

如此反复递归即可得到结果，代码如下，注意，这里使用基于随机数的排序，时间复杂度更好。

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return findKthLargestHelper(nums, 0, nums.length - 1, nums.length - k);
    }

    public int findKthLargestHelper(int[] nums, int l, int r, int k) {
        int s = seperate(nums, l, r);
        if (s < k) {
            return findKthLargestHelper(nums, s + 1 + l, r, k - s - 1);
        } else if (s > k) {
            return findKthLargestHelper(nums, l, s - 1 + l, k);
        } else {
            return nums[s + l];
        }
    }

    public int seperate(int[] nums, int l, int r) {
        if (l == r) {
            return 0;
        }
        Random random = new Random();
        int c = random.nextInt(r - l  + 1) + l;
        swap(nums, c, r);
        int start = l - 1;
        int target = nums[r];
        for (int i = l; i < r; i++) {
            if (nums[i] < target) {
                swap(nums, i, ++start);
            }
        }
        swap(nums, r, ++start);
        return start - l;
    }

    public void swap(int[] nums, int a, int b) {
        int tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
}
```

## 第八章 字符串

字符串的题目共分为5个大类，

### **1.同分异构字符串（如"abc"与"cba"）**

这部分一般都是计数排序：

```java
//童字母异序词判断
public boolean isAnagrame(String s1, String s2) {
    int[] count = new int[26];
    for (int i = 0; i < s1.length(); i++) {
        count[s1.charAt(i) - 'a']++;
        count[s2.charAt(i) - 'a']--;
    }
    for (int num:
         count) {
        if (num != 0) {
            return false;
        }
    }
    return true;
}
```

这个不需要多讲。

### **2.子字符串SubString**

这个主要就是双指针/滑动窗口，例题

> LC 3

```java
//剑指 Offer 48. 最长不含重复字符的子字符串
//这个题作为标准的子字符串题，肯定是双指针/滑动窗口
//这里的精髓在于，这里用的是双指针
//一个p2, 一个i，i好理解，就是当前考察的字符索引
//而这个p2有点门道，这里我们的策略是，
//i一直向右遍历，只要不重复，res就可以一直++,
//若重复，则考察上一次出现的索引位置old与当前索引位置i的差距是否形成新的最大值。若形成则更新
//只要重复，那么解的考察起点就更新为p2与上一次重复的索引的最大值。
public int lengthOfLongestSubstring(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    Map<Character, Integer> map = new HashMap<>();
    int p2 = -1;
    int res = 0;
    for (int i = 0; i < s.length(); i++) {
        if (map.containsKey(s.charAt(i))) {
            p2 = Math.max(p2, map.get(s.charAt(i)));
        }
        map.put(s.charAt(i), i);
        res = Math.max(res, i - p2);
    }
    return res;
}
```

> LC. 159至多包含两个不同字符的最长子串

这个题的基本思路还是双指针，left还是指向搜索起点，right为当前考察节点，注意，这里用hashMap的size来标示是否超过两个不同字符(HashMap存的是特定字符串出现的最后一个索引位置)，若超出，将“最靠前的那个特定类型字符”删除，left从这个字符的最后一个索引位置重新开始调查，

```java
//159. 至多包含两个不同字符的最长子串
public int lengthOfLongestSubstringTwoDistinct(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    if (s.length() < 3) {
        return s.length();
    }
    int left = 0;
    int right = 0;
    int res = 0;
    HashMap<Character, Integer> map = new HashMap<>();
    while (right < s.length()) {
        map.put(s.charAt(right), right++);
        if (map.size() <= 2) {
            res = Math.max(res, right - left);
        }
        if (map.size() == 3) {
            //精髓在这里，
            int newLeft = Collections.min(map.values());
            map.remove(s.charAt(newLeft));
            left = newLeft + 1;
            res = Math.max(res, right - left);
        }
    }
    return res;
}
```

### 3.括号匹配

这种题的一般套路就两种：

1. 结果只有一种的，一般使用栈
2. 结果有多种需要列举的，使用递归回溯。

> #### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```java
public boolean isValid(String s) {
    if (s == null || s.length() == 0) {
        return true;
    }
    Stack<Character> stack = new Stack<>();
    for (char c : s.toCharArray()) {
        if (c == '{') {
            stack.push('}');
        } else if (c == '[') {
            stack.push(']');
        } else if (c == '(') {
            stack.push(')');
        } else {
            if (stack.isEmpty() || stack.pop() != c) {
                return false;
            }
        }
    }
    return stack.isEmpty();
}
```

> #### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

```java
//32. 最长有效括号
//这个题木始终把握一个原则，任意时刻stack里边存储的都是当前还未配对的(的索引，并且
//当前考察点i与stack中所有元素之间的)均已被配对清除。
public int longestValidParentheses(String s) {
    Stack<Integer> stack = new Stack<>();
    //当前考察子串始终为(j, i]
    int res = 0;
    for (int i = 0, j = -1; i < s.length(); i++) {
        if (s.charAt(i) == '(') {
            stack.push(i);
        } else {
            //这个好理解，发现一个)却没有(与之配对，那本轮结束，将j指向i，重新开始下一轮计数
            if (stack.isEmpty()) {
                j = i;
            } else {
                stack.pop();
                //pop之后即为空，代表本轮为完美配对，长度为i - j
                if (stack.isEmpty()) {
                    res = Math.max(res, i - j);
                } else {
                    //pop以后不为空，说明本轮到目前位置，前面仍有一个未配对的（，那么，从这个元素开始
                    //到i为止的元素序列才是当前符合要求的序列
                    res = Math.max(res, i - stack.peek());
                }
            }
        }
    }
    return res;
}
```

> #### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

```java
//22. 括号生成
public List<String> generateParenthesis(int n) {
    List<String> res = new ArrayList<>();
    totalLeft = n;
    generateParenthesisHelper(res, new StringBuilder(), n * 2, 0);
    return res;
}

private int totalLeft = 0;

public void generateParenthesisHelper(List<String> res, StringBuilder sb, int total, int leftCnt) {
    if (total == 0 ) {
        res.add(sb.toString());

    }
    if (totalLeft > 0) {
        sb.append('(');
        totalLeft--;
        generateParenthesisHelper(res, sb,
                                  total - 1, leftCnt + 1);
        sb.delete(sb.length() - 1, sb.length());
        totalLeft++;
    }
    if (leftCnt > 0) {
        sb.append(')');
        generateParenthesisHelper(res, sb,
                                  total - 1, leftCnt - 1);
        sb.delete(sb.length() - 1, sb.length());
    }
}
```

### 4.回文

 <img src="/Users/zhanglulu/Library/Application Support/typora-user-images/image-20210316011638063.png" alt="image-20210316011638063" style="zoom: 25%;" />

> #### [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

这种判断是否是回文串的方式

```java
public boolean isPalindrome(String s) {
    int start = 0, end = s.length() - 1;
    while (start <= end) {
        while (start < end && !Character.isLetterOrDigit(s.charAt(start))) {
            start++;
        }
        while (end > start && !Character.isLetterOrDigit(s.charAt(end))) {
            end--;
        }
        char s1 = s.charAt(start);
        char s2 = s.charAt(end);
        if (Character.toLowerCase(s1) != Character.toLowerCase(s2)) {
            return false;
        }
        start++;
        end--;
    }
    return true;
}
```

# 算法课笔记(下部)

## 第四章 树

不知道为啥，照理来说，树这玩意问的应该比较少，但我TM面了这么多家公司，疯狂问这玩意，我要疯了，照例总结下吧，其实就那么几种题目。

首先来说个基本规则，树的题目一般考察的都是DFS、BFS。

> 三种遍历（非递归实现）

1. 先序遍历

```java
//先序列遍历：
public void preOrderTraversal(TreeNode root) {
    if (root == null) {
        return;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    StringBuilder sb = new StringBuilder();
    while (!stack.isEmpty()) {
        TreeNode tmp = stack.pop();
        sb.append(tmp.val);
        if (tmp.right != null) {
            stack.push(tmp.right);
        }
        if (tmp.left != null) {
            stack.push(tmp.left);
        }
    }
    System.out.println(sb.toString());
}
```

2. 中序遍历

```java
//中序遍历：
public void midOrderTraversal(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    StringBuilder sb = new StringBuilder();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        if (!stack.isEmpty()) {
            TreeNode tmp = stack.pop();
            sb.append(tmp.val);
            cur = tmp.right;
        }
    }
    System.out.println(sb.toString());
}
```

3. 后序遍历

```java
public void afterOderTraversal(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    StringBuilder sb = new StringBuilder();
    TreeNode cur = root;
    TreeNode prev = null;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        if (!stack.isEmpty()) {
            TreeNode temp = stack.peek();
            if (temp.right == null || prev == temp.right) {
                stack.pop();
                sb.append(temp.val);
                prev = temp;
            } else {
                cur = temp.right;
            }
        }
    }
    System.out.println(sb.toString());
}
```

4. 层序遍历(锯齿状)

```java
//层序遍历(BFS)
public void levelOderTraversal(TreeNode root) {
    if (root == null) {
        return;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    StringBuilder sb = new StringBuilder();
    TreeNode last = root, nLast = root;
    while (!queue.isEmpty()) {
        TreeNode temp = queue.poll();
        sb.append(temp.val).append(" ");
        if (temp.left != null) {
            queue.offer(temp.left);
            nLast = temp.left;
        }
        if (temp.right != null) {
            queue.offer(temp.right);
            nLast = temp.right;
        }
        if (temp == last) {
            last = nLast;
            sb.append("\n");
        }
    }
    System.out.println(sb.toString());
}
```

> 其他类型

#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```java
public void flatten(TreeNode root) {
    if (root == null) {
        return;
    }
    Stack<TreeNode> stack = new Stack();
    stack.push(root);
    TreeNode prev = null;
    while (!stack.isEmpty()) {
        TreeNode tmp = stack.pop();
        if (prev != null) {
            prev.left = null;
            prev.right = tmp;
        }
        if (tmp.right != null) {
            stack.push(tmp.right);
        }
        if (tmp.left != null) {
            stack.push(tmp.left);
        }
        prev = tmp;
    }
}
```





## 第十章 动态规划

### 10.2例题

> 300 最长递增子序列

```
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
```

1. DP方法

  动态规划思路如下：

```
输入：int[N] 
状态：dp[i]为从nums[i]为结尾的最长递增子序列长度
状态转移方程：
dp[i] = max{1, dp[j] + 1(j =1...i-1 and nums[i] > nums[j])}
这个状态转移方程需要解释一下，首先针对任意一个元素，总有他自身构成一个递增子序列，因此1是个保底长度。
在此基础上，遍历之前已经算好的dp[j](j < i)，如果有nums[j] < nums[i]，那么dp[j] + 1可以被纳入考虑范围内，最终去一个最大值即可完成dp[i]的计算。
最后，需要在所有dp[i] i = 1...N中去一个最大值，即为最终答案
```

```java
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int[] dp = new int[nums.length];
    Arrays.fill(dp, 1);
    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[j] + 1, dp[i]);
            }
        }
    }
    int res = 0;
    for (int value : dp) {
        res = Math.max(res, value);
    }
    return res;
}
```

2. 贪心算法

```
针对这个题，贪心算法思路如下：
思维角度是：每次都尽可能的将构造而成的递增子序列的末尾数字压到最小(这样才能在后续的数字拼接中尽可能拿到多的长度)


维持一个List，其中，list.get(i)表示，在所有长度为i的递增子序列中，最小的末尾数字取值。
从头到尾遍历nums，这个过程中不断更新list，最终拿到的list长度即为所需最长递增子序列的长度。
更新list的操作为，将nums[i]从list尾部开始，逐步比较，知道找到第一个比nums[i]小的元素，记住其下标j，之后将j+1位置上的数字充值为nums[i]即可。

最终完成的list长度即为所需的最长子序列长度。
```

代码如下：

```java
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    List<Integer> tmp = new ArrayList<>();
    tmp.add(nums[0]);
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > tmp.get(tmp.size() - 1)) {
            tmp.add(nums[i]);
        } else {
            int j = tmp.size() - 1;
            while (j >= 0 && tmp.get(j) >= nums[i]) {
                j --;
            }
            if (j != tmp.size() - 1) {
                tmp.set(j + 1, nums[i]);
            }

        }
    }
    return tmp.size();
}
```

上面这个玩意的时间复杂度依然是O(n2)，可以通过优化中间那一段类似插入排序的玩意，采用二分法减少插入所需计算，将算法时间复杂度压缩值O(nlgn)



> 背包问题(最最经典！！！)

1. 01背包问题

问题描述：

```
现有一个容量为C的背包，N件物品，其所占容量为w[i](i = 1~N)，价值为v[i](i = 1-N)，在N件物品中挑选几件放入背包，使得其总价值最高，不可重复放入。
```

分析过程：

```java
状态与状态转移方程：
1. 状态定义：一般为最终所求结果
2. 参数：
3. 状态转移方程: 一维表示当前变量，二维表示限制条件
```

状态转移方程：

```
定义dp[i][j]为选择范围为前i件物品且背包容量为j时，可获取的最高价值。
dp[i][j] = 
dp[i - 1][j] (w[i] > j)
Max(dp[i - 1][j], dp[i - 1][j - w[i] + v[i]])

如此，最终所需结果即为：
dp[N][C]
```

基于此，首版代码为：

```java
public int baseBackpack(int[] w, int[] v, int N, int C) {
    int[][] dp = new int[N][C + 1];
    for (int i = 0; i <= C; i++) {
        dp[0][i] = i >= w[0] ? v[0] : 0;
    }
    for (int i = 1; i < N; i++) {
        for (int j = 0; j <= C; j++) {
            if (j < w[i]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
            }
        }
    }
    return dp[N - 1][C];
}
```

上述做法为常规写法，其时间复杂度和空间复杂度均为O(N*C)观察这个状态方程可以发现，dp数组求解时，每一行的状态实际上只会依赖与上一行的状态，因此可以可以简化dp数组，采用只有两行的方式进行：

```java
//0-1背包(空间复杂度优化)
public int baseBackpackOp(int[] w, int[] v, int N, int C) {
    int[][] dp = new int[2][C + 1];
    for (int i = 0; i <= C; i++) {
        dp[0][i] = i >= w[0] ? v[0] : 0;
    }
    for (int i = 1; i < N; i++) {
        for (int j = 0; j <= C; j++) {
            int cur = i % 2;
            int past = cur ^ 1;
            if (j < w[i]) {
                dp[cur][j] = dp[past][j];
            } else {
                dp[cur][j] = Math.max(dp[past][j], dp[past][j - w[i]] + v[i]);
            }
        }
    }
    return dp[(N - 1) % 2][C];
}
```

这个方法时间复杂度依然为O(N * C)，但其空间复杂度为O(2N)

再想的极端一些，我们可以进一步把dp数组优化成一维数组，每次直接在上一行数组上更新下一行的数据，这样有个小坑，那就是，状态方程需要取`dp[i - 1][j - w[]]`这个中间值，如果按照正常的逻辑从0向C遍历，那么就有可能导致所需拿到的第`j - w[i]`个元素已经被本行更新过，不再上上一行的数据了，这样就会出错，那就换个思路，从C向0遍历，这样，这种顺序下，第`j - w[i]`个元素绝对是没有被更新过的“上一行元素”，代码如下：

```java
//0-1背包(空间复杂度二次优化)
public int baseBackpackOpMore(int[] w, int[] v, int N, int C) {
    int[] dp = new int[C + 1];
    for (int i = 0; i <= C; i++) {
        dp[i] = i >= w[0] ? v[0] : 0;
    }
    for (int i = 1; i < N; i++) {
        for (int j = C; j >= 0; j--) {
            if (j >= w[i]) {
                dp[j] = Math.max(dp[j], dp[j - w[i]] + v[i]);
            }
            if (j == C && i == N - 1) {
                break;
            }
        }
    }
    return dp[C];
}
```

​		这个算法的空间复杂度就进一步优化为O(N)，当然，时间复杂度依然维持O(N * C)不变。

> 完全背包问题

与0-1背包相似，区别在与，完全背包问题每一件物品都有无限件，可以无限取，结果仍然是N件物品装入容量为C的背包。

按惯例，先来个标准的状态方程：

```java
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]+v[i]], dp[i-1][j-2*w[i]+2*v[i]], ...]
```

这么来看是要在0-1背包的基础上再加一层循环，时间复杂度瞬间爆珠。

因此，我们需要做简化，上面的式子往前退一步：

```java
dp[i][j-w[i]] = max(dp[i-1][j-w[i]], dp[i-1][j-2*w[i]+v[i]], dp[i-1][j-3*w[i]+2*v[i]], ...]
```

联立两式，可得，`dp[i][j-w[i]]+v[i]代替1式中的后半段`则有：

```java
dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])
```

这么猛一看，不就前面正常01背包问题的逻辑一样吗，其实还是有不一样的地方，不同点就在于，这一次内循环不再由后向前，而是保持正序：

```java
public int completeBackpackOpMore(int[] w, int[] v, int N, int C) {
    int[] dp = new int[C + 1];
    for (int i = 0; i < N; i++) {
        for (int j = w[i]; j <= C; j++) {
            dp[j] = Math.max(dp[j], dp[j - w[i]] + v[i]);
        }
    }
    return dp[C];
}
```

如图即可，这里边隐藏逻辑在于，对于01背包问题，倒序遍历可以保证每次遍历到的dp[i]值都是上一行以及计算完毕的中间量，但正序情况下，则各个物品都可能出现两次或两次以上，即满足了上述要求。

> 多重背包

继续变更条件，每一件物品都有固定数量，再次基础上，重新计算可容量为C的背包所能容纳物品的最高价值，这样其实简单了，我们的状态方程如下：

```java
dp[i][j] = max(dp[i-1][j] + dp[i-1][j-k * w[i]] + k * v[i](1 <= k <= nums[i]))
```

同样的，这里也可以做一维化处理：

```java
public int multipleBackpack(int[] w, int[] v, int[] c, int N, int C) {
    int[] dp = new int[C + 1];
    for (int i = 0; i < N; i++) {
        for (int j = C; j >= w[i]; j--) {
            for (int k = 1; k <= c[i] && k * w[i] <= j; k++) {
                dp[j] = Math.max(dp[j], dp[j-w[i]] + k * v[i]);
            }
        }
    }
    return dp[C];
}
```

2. 字符串问题

> 最长回文子串

LC.5 

```
给你一个字符串 s，找到 s 中最长的回文子串。

 

示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"
示例 3：

输入：s = "a"
输出："a"
示例 4：

输入：s = "ac"
输出："a"

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-palindromic-substring
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

本体采用DP做法，状态变量定义为：

```
dp[i][j] : boolean值，表示从i到j的子串是否为回文
```

对应状态方程为

```
dp[i][j] = true (s[i] == s[j] && ((j - i < 2) || dp[i+1][j-1]))
		 = false (else)
```

对应代码如下：

```java
public String longestPalindrome(String s) {
    if (s == null || s.length() <= 1) {
        return s;
    }
    boolean[][] dp = new boolean[s.length()][s.length()];
    for (int i = 0; i < s.length(); i++) {
        dp[i][i] = true;
    }
    int resLength = 1;
    int resStart = 0;
    int resEnd = 0;
    for (int i = 1; i < s.length(); i++) {
        for (int j = 0; j + i < s.length(); j++) {
            int k = j + i;
            if ((k == j + 1 || dp[j + 1][k - 1]) && s.charAt(j) == s.charAt(k)) {
                dp[j][k] = true;
                if (k - j + 1 >= resLength) {
                    resStart = j;
                    resEnd = k;
                    resLength = k - j + 1;
                }
            }
        }
    }
    return s.substring(resStart, resEnd + 1);
}
```

3. 网格问题

> LC 62 不同路径

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

示例 1：

输入：m = 3, n = 7
输出：28
示例 2：

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
示例 3：

输入：m = 7, n = 3
输出：28
示例 4：

输入：m = 3, n = 3
输出：6
```

这个题就比较新鲜一些了，秘诀在于这种网格走法的题目，状态变量设为：

```
dp[i]j[j] : i * j大小的网格从左上角到右下角有多少种走法
```

这种情况下，一般只需要考虑`dp[i][j]`与`dp[i - 1][j]`以及`dp[i][j - 1]`以及`dp[i - 1][j - 1]`之间的关系。

在本题中，状态方程如下：

```
dp[i][j] = dp[i-1][j] + dp[i][j-1] (i > =1 && j > = 1)
		 = 1 (i == 0 || j == 0)
```

这个可以非常容易的想到：在一个i * j大小的网格中，从(0, 0)到(i - 1, j - 1)当前全部路径中（仅可向右或者向下），可以明确分为两类：即1：从(0, 0)到(i-1, j-2)而后到(i-1, j-1)，2：从(0, 0)到(i - 2, j - 1)而后到(i - 1, j - 1)。

代码如下(经过一维优化)：

```java
public int uniquePaths1(int m, int n) {
    int[] dp = new int[n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 || j == 0) {
                dp[j] = 1;
            } else {
                dp[j] += dp[j - 1];
            }
        }
    }
    return dp[n - 1];
}
```



3. 匹配问题（困难）

> 零钱兑换

LC.322

```

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

```

这个题目看似有点像背包问题，但其实因为要求必须凑够一个总金额(不能多，也不能少)，所以状态方程及状态变量是有变化的：

```
状态变量：dp[i] 总金额为i是最少需要的硬币数量
状态方程：
dp[i] = min(dp[i - coins[j]] + 1 when j = 1..n)
dp[0] = 0;
这个思路算是有点逆向的意思，关键控制变量为最后一个硬币选哪一个面值，减去不同面值所需数量的最小值再加1就可以得到最终的结果了。
```

代码如下：

```java
public int coinChange(int[] coins, int amount) {
    if (amount == 0) {
        return 0;
    }

    int[] dp = new int[amount + 1];
    //这里又个小坑，为什么要赋值为amount+1呢，这是因为本题的场景中存在一种无论如何都无法恰好配满目标值的情况，这个时候需要一个特定的变量来表示，很显然，amount+1这个数量的硬币总额必然是大于amount的，所以选取该值一定是安全的。
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    for (int i = 1; i <= amount; i++) {
        for (int j = 0; j < coins.length; j++) {
            if (i - coins[j] >= 0) {
                dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
            }
        }
    }
    //最后就用根据之前定义好的非法值amount+1来判定是否需要返回-1了。
    return dp[amount] == amount + 1? -1 :dp[amount];
}
```

> 组合总和

LC. 377

```
给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

示例:

nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。
```

这个题的状态选法和上一个零钱兑换很像：

```
状态变量：dp[i] 总和为i的组合个数
状态方程：dp[i] = sum(dp[i - num[k], k = 1..n])(n为数字总数)
```

如此代码就很简单了：

```java
public int combinationSum4(int[] nums, int target) {
    int[] dp = new int[target + 1];
    dp[0] = 1;
    for (int i = 1; i < target + 1; i++) {
        int res = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] <= i) {
                res += dp[i - nums[j]];
            }
        }
        dp[i] = res;
    }
    return dp[target];
}
```

> 最长递增子序列

```
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

 
示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4
示例 3：

输入：nums = [7,7,7,7,7,7,7]
输出：1
```

```
状态变量：dp[i] 以下标为i的数结尾递增子序列长度
状态转移方程：dp[i] = max(dp[j] + 1) (j = 0..i-1 && nums[j] < nums[i])
解析：
这里的理解思路在于：以nums[i]结尾的递增子序列，考虑倒数第二个数的取值，尝试去不同的值，保证满足递增的前提下，取最大值+1，即可得到dp[i]
```

代码如下：

```java
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int[] dp = new int[nums.length];
    Arrays.fill(dp, 1);
    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[j] + 1, dp[i]);
            }
        }
    }
    int res = 0;
    for (int value : dp) {
        res = Math.max(res, value);
    }
    return res;
}
```

# 追加：难题总结

接雨水：

```
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```

**分析**：这个题最好的方法是单调栈，单调栈顾名思义，就是内部从栈底到栈顶，维持单调递增/减的栈，这个题目中的应用思路如下：
在维护了一个从栈底到栈顶逐渐递减的栈的基础上，如果发现一个比当前栈顶元素(余下称为bot)还要高的柱子(一下称为cur)，那么以bot为底，cur以及bot的上一个元素为顶的池子就出现了，可以参与一次考察，之后可以吧bot出栈，这个时候循环上述逻辑，尝试以bot的上一个元素为底，再次考察。

代码如下：

```java
class Solution {
    public int trap(int[] height) {
        Stack<Integer> stack = new Stack();
        int idx = 0, res = 0;
        while (idx < height.length) {
            while (!stack.isEmpty() && height[stack.peek()] < height[idx]) {
                int bot = stack.pop();
                if (stack.isEmpty()) {
                    break;
                }         
                int len = idx - stack.peek() - 1;
                res += len * (Math.min(height[stack.peek()], height[idx]) - height[bot]);
            }
            stack.push(idx++);
        }
        return res;
    }
}
```



